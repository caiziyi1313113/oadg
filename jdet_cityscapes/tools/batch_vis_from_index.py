#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import json
import subprocess
import sys
from pathlib import Path


def _as_entries(index_data):
    if isinstance(index_data, list):
        return index_data
    if isinstance(index_data, dict):
        # expected format from test_robustness.py: {"corr|sev": {...record...}}
        if all(isinstance(v, dict) for v in index_data.values()):
            return list(index_data.values())
        # fallback: {"entries": [...]}
        entries = index_data.get("entries")
        if isinstance(entries, list):
            return entries
    raise ValueError("Unsupported index json format.")


def _entry_key(entry):
    corr = str(entry.get("corruption", ""))
    sev = entry.get("severity", -1)
    try:
        sev_i = int(sev)
    except Exception:
        sev_i = -1
    return corr, sev_i


def _resolve_path(base_dir, path_str):
    if path_str is None:
        return None
    p = Path(path_str)
    if p.is_absolute():
        return p
    return (base_dir / p).resolve()


def parse_args():
    parser = argparse.ArgumentParser(
        description="Batch visualize COCO predictions from test_robustness index.json"
    )
    parser.add_argument(
        "--index-file",
        required=True,
        help="index json generated by test_robustness.py (det_boxes/index.json)",
    )
    parser.add_argument(
        "--det-root",
        default=None,
        help="base dir for relative pred paths in index (default: parent of --index-file)",
    )
    parser.add_argument(
        "--out-root",
        default=None,
        help="output root for visualization images (default: <det-root>/vis_batch)",
    )
    parser.add_argument(
        "--mode",
        choices=["gt", "pred", "both"],
        default="both",
        help="visualization mode passed to vis_coco_boxes.py",
    )
    parser.add_argument("--score-thr", type=float, default=0.05)
    parser.add_argument("--max-det", type=int, default=200)
    parser.add_argument("--max-images", type=int, default=0, help="0 means all")
    parser.add_argument("--seed", type=int, default=0)
    parser.add_argument("--skip-existing", action="store_true")
    parser.add_argument("--fixed-color", action="store_true")
    parser.add_argument(
        "--corruptions",
        nargs="+",
        default=None,
        help="optional corruption names to include",
    )
    parser.add_argument(
        "--severities",
        type=int,
        nargs="+",
        default=None,
        help="optional severity values to include",
    )
    parser.add_argument("--dry-run", action="store_true")
    return parser.parse_args()


def main():
    args = parse_args()

    index_file = Path(args.index_file).resolve()
    if not index_file.exists():
        raise SystemExit(f"[ERR] index file not found: {index_file}")

    det_root = Path(args.det_root).resolve() if args.det_root else index_file.parent
    out_root = Path(args.out_root).resolve() if args.out_root else (det_root / "vis_batch")
    out_root.mkdir(parents=True, exist_ok=True)

    vis_script = (Path(__file__).resolve().parent / "vis_coco_boxes.py").resolve()
    if not vis_script.exists():
        raise SystemExit(f"[ERR] vis script not found: {vis_script}")

    with open(index_file, "r", encoding="utf-8") as f:
        index_data = json.load(f)
    entries = _as_entries(index_data)
    entries = [e for e in entries if isinstance(e, dict)]
    entries.sort(key=_entry_key)

    if args.corruptions is not None:
        allowed_corr = set(args.corruptions)
        entries = [e for e in entries if e.get("corruption") in allowed_corr]
    if args.severities is not None:
        allowed_sev = set(args.severities)
        entries = [e for e in entries if int(e.get("severity", -1)) in allowed_sev]

    if not entries:
        print("[WARN] no entries to visualize after filtering.")
        return

    ok = 0
    fail = 0
    skip = 0

    for entry in entries:
        corr = str(entry.get("corruption", "unknown"))
        sev = int(entry.get("severity", -1))
        ann_file = entry.get("ann_file")
        img_root = entry.get("img_root")
        pred_rel_or_abs = entry.get("pred_file")
        pred_file = _resolve_path(det_root, pred_rel_or_abs)

        out_dir = out_root / corr / f"severity_{sev}"

        if ann_file is None or img_root is None or pred_file is None:
            print(f"[SKIP] {corr}/severity_{sev}: missing ann/img_root/pred path")
            skip += 1
            continue
        if not Path(ann_file).exists():
            print(f"[SKIP] {corr}/severity_{sev}: ann file not found: {ann_file}")
            skip += 1
            continue
        if not Path(img_root).exists():
            print(f"[SKIP] {corr}/severity_{sev}: img root not found: {img_root}")
            skip += 1
            continue
        if not pred_file.exists():
            print(f"[SKIP] {corr}/severity_{sev}: pred file not found: {pred_file}")
            skip += 1
            continue

        cmd = [
            sys.executable,
            str(vis_script),
            "--ann-file",
            str(ann_file),
            "--img-root",
            str(img_root),
            "--pred-file",
            str(pred_file),
            "--mode",
            args.mode,
            "--out-dir",
            str(out_dir),
            "--score-thr",
            str(args.score_thr),
            "--max-det",
            str(args.max_det),
            "--max-images",
            str(args.max_images),
            "--seed",
            str(args.seed),
        ]
        if args.skip_existing:
            cmd.append("--skip-existing")
        if args.fixed_color:
            cmd.append("--fixed-color")

        print(f"[RUN] {corr}/severity_{sev}")
        if args.dry_run:
            print("      " + " ".join(cmd))
            ok += 1
            continue

        proc = subprocess.run(cmd, capture_output=False)
        if proc.returncode == 0:
            ok += 1
        else:
            fail += 1
            print(f"[ERR] visualize failed for {corr}/severity_{sev}")

    print(
        f"[DONE] total={len(entries)} ok={ok} fail={fail} skip={skip} "
        f"out_root={out_root}"
    )


if __name__ == "__main__":
    main()
